pragma solidity ^0.4.24;
pragma experimental ABIEncoderV2;

import '../coffeecore/Ownable.sol';
import '../coffeeaccesscontrol/FarmerRole.sol';
import '../coffeeaccesscontrol/DistributorRole.sol';
import '../coffeeaccesscontrol/RetailerRole.sol';
import '../coffeeaccesscontrol/ConsumerRole.sol';

/*
The contract inherits from the role contracts in order to apply the respective permissions on the state changing actions
*/
contract SupplyChain is Ownable, FarmerRole, DistributorRole, RetailerRole, ConsumerRole {

    // Universal Product Code (UPC)
    uint upc;

    // Stock Keeping Unit (SKU)
    uint sku;

    mapping (uint => Item) items;

    enum State
    {
        Harvested,    // 0
        Processed,    // 1
        Packed,       // 2
        ForSale,      // 3
        Sold,         // 4
        Shipped,      // 5
        Received,     // 6
        Purchased     // 7
    }

    State constant defaultState = State.Harvested;

    // Define a struct 'Item' with the following fields:
    struct Item {
        // Stock Keeping Unit (SKU)
        uint sku;

        // Universal Product Code (UPC), generated by the Farmer, goes on the package, can be verified by the Consumer
        uint upc;

        // Metamask-Ethereum address of the current owner as the product moves through 8 stages
        address ownerID;

        // Metamask-Ethereum address of the Farmer
        address originFarmerID;

        // Farmer Name
        string originFarmName;

        // Farmer Information
        string originFarmInformation;

        // Farm Latitude
        string originFarmLatitude;

        // Farm Longitude
        string originFarmLongitude;

        // Product ID potentially a combination of upc + sku
        uint productID;

        // Product Notes
        string productNotes;

        // Product Image IPFS hash
        string productImageIPFSHash;

        // Product Price
        uint productPrice;

        // Product State as represented in the enum above
        State itemState;

        // Metamask-Ethereum address of the Distributor
        address distributorID;

        // Metamask-Ethereum address of the Retailer
        address retailerID;

        // Metamask-Ethereum address of the Consumer
        address consumerID;
    }

    event Harvested(uint upc);
    event Processed(uint upc);
    event Packed(uint upc);
    event ForSale(uint upc);
    event Sold(uint upc);
    event Shipped(uint upc);
    event Received(uint upc);
    event Purchased(uint upc);

    constructor() public payable {
        sku = 1;
        upc = 1;
    }

    function kill() public {
        if (isOwner()) {
            selfdestruct(owner);
        }
    }

    function harvestItem(
        uint _upc,
        string _originFarmName,
        string _originFarmInformation,
        string _originFarmLatitude,
        string _originFarmLongitude,
        string _productNotes,
        string _productImageIPFSHash
    )
        public onlyFarmer
    {

        require(items[_upc].upc == 0, "upc already exists");

        items[_upc] = Item({
            sku: sku,
            upc: _upc,
            ownerID: msg.sender,
            originFarmerID: msg.sender,
            originFarmName: _originFarmName,
            originFarmInformation: _originFarmInformation,
            originFarmLatitude: _originFarmLatitude,
            originFarmLongitude: _originFarmLongitude,
            productID: sku + _upc,
            productNotes: _productNotes,
            productImageIPFSHash: _productImageIPFSHash,
            productPrice: 0,
            itemState: State.Harvested,
            distributorID: 0x0,
            retailerID: 0x0,
            consumerID: 0x0
        });

        sku = sku + 1;

        emit Harvested(_upc);
    }

    function processItem(uint _upc) public onlyFarmer{
        Item storage item = items[_upc];

        require(msg.sender == item.originFarmerID, "sender is not the original farmer");

        require(item.itemState == State.Harvested, "item is not harvested yet");

        item.itemState = State.Processed;

        emit Processed(_upc);
    }

    function packItem(uint _upc) public onlyFarmer {
        Item storage item = items[_upc];

        require(msg.sender == item.originFarmerID, "sender is not the original farmer");

        require(item.itemState == State.Processed, "item is not processed yet");

        item.itemState = State.Packed;

        emit Packed(_upc);
    }

    function sellItem(uint _upc, uint _price) public onlyFarmer {
        Item storage item = items[_upc];

        require(msg.sender == item.originFarmerID, "sender is not the original farmer");

        require(item.itemState == State.Packed, "item is not packed yet");

        item.itemState = State.ForSale;
        item.productPrice = _price;

        emit ForSale(_upc);
    }

    function buyItem(uint _upc) public payable onlyDistributor {
        Item storage item = items[_upc];

        require(item.itemState == State.ForSale, "item is not for sale yet");

        require(msg.value >= item.productPrice, "insufficient value");

        item.ownerID = msg.sender;
        item.distributorID = msg.sender;
        item.itemState = State.Sold;

        uint _price = item.productPrice;
        uint amountToReturn = msg.value - _price;
        item.consumerID.transfer(amountToReturn);

        emit Sold(_upc);
    }

    function shipItem(uint _upc) public onlyDistributor{
        Item storage item = items[_upc];

        require(msg.sender == item.distributorID, "sender is not the original distributor");

        require(item.itemState == State.Sold, "item is not bought yet");

        item.itemState = State.Shipped;

        emit Shipped(_upc);
    }

    function receiveItem(uint _upc) public onlyRetailer {
        Item storage item = items[_upc];

        require(item.itemState == State.Shipped, "item is not shipped yet");

        item.ownerID = msg.sender;
        item.retailerID = msg.sender;
        item.itemState = State.Received;

        emit Received(_upc);
    }

    function purchaseItem(uint _upc) public onlyConsumer {
        Item storage item = items[_upc];

        require(item.itemState == State.Received, "item is not received yet by the retailer");

        item.ownerID = msg.sender;
        item.consumerID = msg.sender;
        item.itemState = State.Purchased;

        emit Purchased(_upc);
    }

    function fetchItem(uint _upc) public view returns (Item) {
        return items[_upc];
    }
}
